#!/bin/bash
# compress overlarge files of scanned documents, run with -h for help
# for similar but different approaches see https://askubuntu.com/questions/113544/how-can-i-reduce-the-file-size-of-a-scanned-pdf-file
# esp the answer that starts 'If you have a pdf with scanned images...'

VERSION="0.5 [16 Nov 2017]"
THIS=$(basename $0)
COLUMNS=$(stty size 2>/dev/null||echo 80); COLUMNS=${COLUMNS##* }
set -o pipefail
RESIZEPCT=200
NEGATE="-negate"

while getopts ":fhlnp:qr:t:vwy" optname; do
    case "$optname" in
		"h")	HELP="y";;
		"l")	CHANGELOG="y";;
		"n")	unset NEGATE;;
		"p")	PARAMS=( $OPTARG );;
		"q")	QUIET="q";;
		"r")	RESIZEPCT="$OPTARG";;
		"t")	DTEMP="$OPTARG";;
		"v")	VERBOSE="y";;
		"w")	COLUMNS=30000;;
		"y")	OVERWRITE="y";;
		"?")	echo "Unknown option $OPTARG">&2; exit 1;;
		":")	echo "No argument value for option $OPTARG">&2; exit 1;;
		*)	# Should not occur
			echo "Unknown error while processing options">&2; exit 1;;
    esac
done
shift $(($OPTIND-1))
[[ -n $VERBOSE$HELP$CHANGELOG && -z $QUIET ]] && echo -e "\n$THIS v$VERSION - by Dominic (-h for help)\n${THIS//?/=}\n"
if [[ -n $HELP ]]; then
	echo -e "Compress an overlarge pdf file. Use case is a file \
generated by scanning with unnecessarily high resolution and/or \
color. The aim is to produce a file that is black-and-white \
but still legible and much smaller. It does not always \
succeed (result may not be legible, or may be larger), but when it \
works it can dramatically reduce file sizes (90%+) while maintaining \
good legibility. This is achieved by conversion to 1-bit pixel mapping, so \
is typically most effective for black text on a white background.

If destination path/file is unspecified $THIS will create a file in the same \
location as source, with -1 suffixed to the filename (before .pdf extension). \
If destination is a directory then the created \
file will have the same name as the source file.

Using a different resize percentage (default 200) does not affect the \
physical size of the pages in the destination file, but will alter the \
file size and quality as well as the speed of operation - you may have \
to experiment to get the best \
balance with each original (or type of such). Note that the use of \
high figures (say 300+) is exponentially slower and can cause \
$THIS to run out of memory.

Specify additional options to be passed to the image-magick \
convert operation within $THIS by using -p; for instance, to hide a watermark \
try -p '-white-threshold 60%'.

Usage: ./$THIS [options] source_path/filename [destination_path[/filename]]

Options   : -h - show this help and exit
            -l - show changelog and exit
            -n - negative result (black becomes white and vice-versa) - sometimes needed to correct auto-negation
            -p - specify extra parameters for convert e.g. -p '-white-threshold 60%'
            -q - quiet output
            -r num - resize percentage (1+, default 200; note that use of \
high figures say 300+ will be exponentially slower and can cause \
out-of-memory failures)
            -v - be more verbose
            -t path - directory to use for temporary files, which can be \
large (default: /tmp)
            -y - overwrite destination file if it already exists

Dependencies: bash 4+, image-magick, ghostscript (gs)
"|fold -s -w $COLUMNS
fi
if [[ -n $CHANGELOG ]]; then
	[ -n "$HELP" ] && echo "Changelog:"
	echo -e "\
0.5 [16 Nov 2017] - negate by default (-n to non-negate), default resize 200 not 100, add -p option
0.4 [23 Apr 2017] - add -n (negative) option
0.3 [16 Oct 2016] - fix for temporary file deletion, make temporary filenames unique
0.2 [21 Sep 2016] - lots of tweaks
0.1 [20 Sep 2016] - initial version
"|fold -s -w $COLUMNS
fi
[[ -n $HELP$CHANGELOG ]] && exit 0
[[ -z $VERBOSE$QUIET ]] && echo -n "$THIS: "

# check that we have valid inputs
[[ -z $DTEMP ]] && DTEMP=/tmp
[[ -d $DTEMP ]] ||  { echo "Can't locate temporary directory '$DTEMP': aborting" >&2; exit 1; }
TMPPRE=$DTEMP/$THIS-$(id -u)

#echo "PARAMS has ${#PARAMS[@]} elements: 0 is '${PARAMS[0]}', 1 is '${PARAMS[1]}'"; exit 0
SOURCE=$1
[[ -s $SOURCE ]] || { echo "Can't locate source file '$SOURCE': aborting" >&2; exit 1; }
SFILE="$(basename "$SOURCE")"
# this is a crude test for pdf file, but note that some code below depends on the source file having a 3-character extension
[[ ${SFILE:$((${#SFILE}-4))} =~ \.[Pp][Dd][Ff] ]] || { echo "Source file '$SOURCE' is not pdf, aborting" >&2; exit 1; }
SDIR="$(dirname "$SOURCE")"
SSIZE=$(stat -c%s "$SOURCE")
#echo -e "Source is '$SOURCE'\nSDIR is '$SDIR'"
[[ -d $SDIR ]] || { echo "Can't locate source directory '$SDIR': aborting" >&2; exit 1; }

DEST=$2
if [[ -z $DEST ]]; then
	DEST="$SDIR/${SFILE:0:$((${#SFILE}-4))}-1${SFILE:$((${#SFILE}-4))}"
elif [[ -d $DEST ]]; then
	[[ ${DEST:$((${#DEST}-1))} == "/" ]] && DEST=$DEST$SFILE || DEST=$DEST/$SFILE
fi
DDIR="$(dirname "$DEST")"
[[ -d $DDIR ]] || { echo "Can't locate destination directory '$DDIR': aborting" >&2; exit 1; }
#echo -e "DDIR: '$DDIR'\nDEST: '$DEST'"; exit 0
[[ -n $OVERWRITE || ! -f $DEST ]]  || { echo "Won't overwrite existing destination file '$DEST', specify -y to override, aborting" >&2; exit 1; }
# yes I realise this could be tricked and then overwriting would then be possible
[[ $DEST != $SOURCE ]] || { echo "Won't overwrite original file '$SOURCE', aborting" >&2; exit 1; }

[[ $RESIZEPCT =~ [1-9][0-9]* ]] || { echo "Resize percentage '$RESIZEPCT' is invalid, aborting" >&2; exit 1; }
hash mogrify 2>/dev/null || { echo "Can't locate mogrify - imagemagick packages must be installed e.g. apt-get install imagemagick" >&2; exit 1; }
hash gs 2>/dev/null || { echo "Can't locate gs - ghostscript packages must be installed e.g. apt-get install ghostscript" >&2; exit 1; }

# we are good to go

# delete any left-over temporary files (from a previous failed run)
find "$DTEMP" -maxdepth 1 -regextype posix-extended -regex "$TMPPRE-[0-9]*-[0-9][0-9][0-9]\.png.*" -delete || { echo "Unable to delete pre-existing temporary files, aborting" >&2; exit 1; }

[[ -n $VERBOSE ]] && echo -n "Extracting pages from $SOURCE: "
gs -sDEVICE=pngalpha -dNOPAUSE -dBATCH -sOutputFile="$TMPPRE-$$-%03d.png" "$SOURCE" >/dev/null 2>&1 || { echo "An error occurred, aborting" >&2; exit 1; }
[[ -n $VERBOSE ]] && echo -n "OK"

# make an ordered list in $TMPF of the page-by-page png files we have just created
TMPF=$(mktemp)
find "$DTEMP" -maxdepth 1 -regex "$TMPPRE-$$-[0-9][0-9][0-9].png"|sort >$TMPF

# resizing and conversion to mono 1-bit: better images and faster if done in two stages

#  1: resize the file
if [[ $RESIZEPCT != 100 ]]; then
	[[ -n $VERBOSE ]] && echo -en "\nResizing pages ${RESIZEPCT}%: "
	while read FILE; do
		let COUNTER++; [[ -n $VERBOSE ]] && echo -n "$COUNTER "
		# mogrify does an in-place file resize
		mogrify -resize ${RESIZEPCT}% "$FILE" || { echo "An error occurred, aborting" >&2; exit 1; }
	done <$TMPF
fi

#  2: convert to mono 1-bit (bitmap)
if [[ -n $VERBOSE ]]; then
	echo -en "\nConverting to black and white 1-bit-per-pixel format"
	[[ -n ${PARAMS[@]} ]] && echo " (using: ${PARAMS[@]})"
	echo -en ": "
fi
COUNTER=0
while read FILE; do
	let COUNTER++; [[ -n $VERBOSE ]] && echo -n "$COUNTER "
	# creating true 1-bit bmp with imagemagick convert is not at all obvious, most settings don't work
	#   kudos: https://poizan.dk/blog/2014/02/28/monochrome-images-in-imagemagick/ (proof: check with identify)
	convert "$FILE" ${PARAMS[@]} -monochrome -colors 2 "$FILE".bmp || { echo "An error occurred, aborting" >&2; exit 1; }
	rm "$FILE"	# we no longer need the intermediate .png file, so save space by getting rid of it now
done <$TMPF

#  3: combine bmp files to create a new pdf file
#     LZW compression can give very slightly higher compression, but Fax is standard for b/w scans and almost as good
[[ -n $VERBOSE ]] && echo -en "\nBuilding $DEST: "
convert $(cat $TMPF|sed 's/$/.bmp/') $NEGATE -compress Fax "$DEST" || { echo "An error occurred, aborting" >&2; exit 1; }
[[ -n $VERBOSE ]] && echo "OK"
# tidy up by removing .bmp files and TMPF listing file
find "$DTEMP" -maxdepth 1 -regex "$TMPPRE-$$-[0-9][0-9][0-9]\.png\.bmp"] -delete
rm $TMPF

# we're done, tell the world how good we've been
[[ -z $QUIET ]] && DSIZE=$(stat -c%s "$DEST") && echo -e "$DEST [$(($DSIZE/1024))K] from $SOURCE [$(( $SSIZE/1024 ))K], compression $(( ($SSIZE-$DSIZE)/1024 ))K [$(( 100-100*$DSIZE/$SSIZE ))%]"
exit 0
